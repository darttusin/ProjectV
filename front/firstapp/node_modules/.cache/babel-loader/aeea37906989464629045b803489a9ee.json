{"ast":null,"code":"function e(e, t, n) {\n  let r = [d.run({\n    fn: e => t(e)\n  })];\n\n  if (n) {\n    let t = y({\n      node: r\n    }),\n        o = e.graphite.id,\n        u = n.additionalLinks,\n        a = u[o] || [];\n    return u[o] = a, a.push(t), () => {\n      let e = a.indexOf(t);\n      -1 !== e && a.splice(e, 1), k(t);\n    };\n  }\n\n  {\n    let t = y({\n      node: r,\n      parent: [e],\n      family: {\n        owners: e\n      }\n    });\n    return () => {\n      k(t);\n    };\n  }\n}\n\nfunction t(e, t) {\n  return t.displayName = e, t;\n}\n\nfunction n(t, n) {\n  g.store(t) || S('expect useStore argument to be a store');\n  let r = w(t, n),\n      o = N(),\n      u = m.useRef({\n    store: t,\n    value: r,\n    pending: 0\n  });\n  return b(() => {\n    let r = e(t, e => {\n      let t = u.current;\n      t.pending || (t.value = e, t.pending = 1, o(), t.pending = 0);\n    }, n),\n        a = w(t, n),\n        s = u.current;\n    return s.store === t && s.value !== a && (s.value = a, s.pending = 1, o(), s.pending = 0), s.store = t, r;\n  }, [t, n]), r;\n}\n\nfunction r([t, n], r) {\n  let u,\n      a,\n      s,\n      l = j;\n  n ? (u = n, a = t, s = []) : (u = t.fn, a = t.store, s = t.keys, l = t.updateFilter || j), g.store(a) || S('useStoreMap expects a store'), Array.isArray(s) || S('useStoreMap expects an array as keys'), 'function' != typeof u && S('useStoreMap expects a function');\n  let c = m.useRef({}),\n      i = c.current;\n  i.fn = u, i.upd = l, i.init = i.store === a, i.store = a;\n  let f = N(),\n      p = [r, ...s],\n      d = m.useMemo(() => (o(w(a, r), s, c.current), e(a, e => o(e, s, c.current, f), r)), p);\n  return b(() => () => d(), p), i.val;\n}\n\nfunction o(e, t, n, r) {\n  let o = n.fn(e, t);\n  n.init ? void 0 !== o && j(o, n.val) && n.upd(o, n.val) && (n.val = o, r && r()) : (n.val = o, n.init = 1);\n}\n\nfunction u(e) {\n  return e;\n}\n\nfunction a(e) {\n  return n(e);\n}\n\nfunction s(e, t) {\n  return r([e, t]);\n}\n\nfunction l(e, o) {\n  return ((e, o, u) => {\n    let a,\n        s,\n        l = [];\n    'object' == typeof o && null !== o ? (o.keys && (l = o.keys), a = o.fn, o.getKey && (s = o.getKey)) : a = o, g.store(e) || S('expect useList first argument to be a store'), 'function' != typeof a && S(\"expect useList's renderItem to be a function\"), Array.isArray(l) || S(\"expect useList's keys to be an array\");\n    let c = m.useMemo(() => {\n      let n = t(`${e.shortName || 'Unknown'}.Item`, t => {\n        let {\n          index: n,\n          keys: o,\n          keyVal: a,\n          value: s\n        } = t;\n        if (i.current[1]) return i.current[0](s, a);\n        let l = r([{\n          store: e,\n          keys: [n, ...o],\n          fn: (e, t) => e[t[0]]\n        }], u);\n        return i.current[0](l, n);\n      });\n      return m.memo(n);\n    }, [e, u, !!s]),\n        i = m.useRef([a, s]);\n    i.current = [a, s];\n    let f = m.useMemo(() => l, l);\n    if (s) return n(e, u).map(e => {\n      let t = i.current[1](e);\n      return m.createElement(c, {\n        keyVal: t,\n        key: t,\n        keys: f,\n        value: e\n      });\n    });\n    {\n      let t = r([{\n        store: e,\n        keys: [e],\n        fn: e => e.length\n      }], u);\n      return Array.from({\n        length: t\n      }, (e, t) => m.createElement(c, {\n        index: t,\n        key: t,\n        keys: f\n      }));\n    }\n  })(e, o);\n}\n\nfunction c(e, n) {\n  function r(e) {\n    let t = m.useRef(e),\n        r = a(o);\n    b(() => (s({\n      props: t.current,\n      state: o.getState()\n    }), () => {\n      l({\n        props: t.current,\n        state: o.getState()\n      });\n    }), []);\n    let u = n(e, r);\n    return t.current = e, u;\n  }\n\n  let o;\n  g.store(e) ? o = e : 'object' == typeof e && null !== e ? o = v(e) : S('shape should be a store or object with stores');\n  let u = 'Unknown';\n  o && o.shortName && (u = o.shortName);\n  let s = h(),\n      l = h();\n  return r.mounted = s, r.unmounted = l, t(`${u}.View`, r);\n}\n\nfunction i(e) {\n  return c(e, ({\n    children: e\n  }, t) => e(t));\n}\n\nfunction f(e, t = {}) {\n  let n = m.useRef({\n    value: null,\n    count: 0\n  });\n  b(() => (e.open(n.current.value), () => e.close(n.current.value)), [e]), ((e, t) => {\n    if (e === t) return 1;\n\n    if ('object' == typeof e && null !== e && 'object' == typeof t && null !== t) {\n      let n = Object.keys(e),\n          r = Object.keys(t);\n      if (n.length !== r.length) return 0;\n\n      for (let r = 0; r < n.length; r++) {\n        let o = n[r];\n        if (e[o] !== t[o]) return 0;\n      }\n\n      return 1;\n    }\n\n    return 0;\n  })(n.current.value, t) || (n.current.value = t, n.current.count += 1), b(() => {\n    e.set(n.current.value);\n  }, [n.current.count]);\n}\n\nfunction p(e = \"gate\", n = {}) {\n  let r;\n  return 'object' == typeof e && null !== e && ('defaultState' in e && (n = e.defaultState), e.domain && (r = e.domain), e = e.name), (({\n    name: e = \"gate\",\n    domain: n,\n    defaultState: r,\n    hook: o\n  }) => {\n    function u(e) {\n      return o(u, e), null;\n    }\n\n    let a = `${n ? `${n.compositeName.fullName}/` : ''}${e}`,\n        s = h(`${a}.set`),\n        l = h(`${a}.open`),\n        c = h(`${a}.close`),\n        i = x(Boolean(0), {\n      name: `${a}.status`\n    }).on(l, () => Boolean(1)).on(c, () => Boolean(0)),\n        f = x(r, {\n      name: `${a}.state`\n    }).on(s, (e, t) => t).reset(c);\n\n    if (n) {\n      let {\n        hooks: e\n      } = n;\n      $({\n        target: [e.store, e.store, e.event, e.event, e.event],\n        params: [i, f, l, c, s]\n      });\n    }\n\n    return u.open = l, u.close = c, u.status = i, u.state = f, u.set = s, t(`Gate:${a}`, u);\n  })({\n    name: e,\n    domain: r,\n    defaultState: n,\n    hook: f\n  });\n}\n\nimport m from 'react';\nimport { step as d, createNode as y, clearNode as k, is as g, combine as v, createEvent as h, createStore as x, launch as $ } from 'effector/effector.mjs';\n\nlet b = 'undefined' != typeof window ? m.useLayoutEffect : m.useEffect,\n    S = e => {\n  throw Error(e);\n};\n\nconst w = (e, t) => t ? t.getState(e) : e.getState(),\n      j = (e, t) => e !== t,\n      N = () => m.useReducer(e => e + 1, 0)[1];\n\nlet R = e => console.error(`${e} is deprecated`),\n    C = (e, n, r) => (R('createContextComponent'), t(`${e.shortName || 'Unknown'}.ContextComponent`, t => {\n  let o = m.useContext(n),\n      u = a(e);\n  return r(t, u, o);\n})),\n    E = e => n => {\n  let r = e;\n  return 'function' != typeof e && (r = n, n = e), t(`Connect(${r.displayName || r.name || 'Unknown'})`, e => m.createElement(r, { ...e,\n    ...a(n)\n  }));\n},\n    M = (e, t) => (R('createReactState'), E(t)(e));\n\nexport { E as connect, c as createComponent, C as createContextComponent, p as createGate, M as createReactState, i as createStoreConsumer, u as useEvent, f as useGate, l as useList, a as useStore, s as useStoreMap };","map":{"version":3,"sources":["effector-react/createWatch.ts","effector-react/withDisplayName.ts","effector-react/apiBase.ts","effector-react/nossr.ts","effector-react/createComponent.ts","effector-react/createStoreConsumer.ts","effector-react/createGate.ts","effector-react/useIsomorphicLayoutEffect.ts","effector-react/throw.ts","effector-react/deprecate.ts","effector-react/createContextComponent.ts","effector-react/connect.ts","effector-react/createReactState.ts"],"names":["createWatch","store","fn","scope","seq","step","run","value","node","createNode","id","graphite","scopeLinks","additionalLinks","links","push","idx","indexOf","splice","clearNode","parent","family","owners","withDisplayName","name","Component","displayName","stateReader","getState","basicUpdateFilter","upd","oldValue","createNotifier","React","useReducer","n","useStoreBase","is","throwError","currentValue","inc","currentStore","useRef","pending","useIsomorphicLayoutEffect","stop","ref","current","newValue","useStoreMapBase","configOrStore","separateFn","updateFilter","keys","Array","isArray","result","refState","init","deps","useMemo","updateRef","val","sourceValue","undefined","list","renderItem","getKey","Item","shortName","props","index","keyVal","fnRef","item","memo","keysSelfMemo","map","key","createElement","length","from","_","i","useEvent","event","useStore","useStoreMap","useList","createComponent","shape","renderProp","combine","storeName","mounted","createEvent","unmounted","RenderComponent","propsRef","state","createStoreConsumer","children","useGate","GateComponent","count","open","close","shallowCompare","set","a","b","aKeys","Object","bKeys","domain","defaultState","hook","useGateHook","fullName","compositeName","status","createStore","Boolean","on","reset","hooks","launch","target","params","createGate","window","useLayoutEffect","useEffect","message","Error","deprecate","method","console","error","createContextComponent","context","ctx","useContext","connect","View","createReactState"],"mappings":"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","sourcesContent":["import {Store, clearNode, step, createNode, Scope, Node} from 'effector'\n\nexport function createWatch<T>(\n  store: Store<T>,\n  fn: (value: T) => any,\n  scope?: Scope,\n) {\n  const seq = [step.run({fn: value => fn(value)})]\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (store as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return () => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    }\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [store],\n      family: {owners: store},\n    })\n    return () => {\n      clearNode(node)\n    }\n  }\n}\n","export function withDisplayName(name: string, Component: any) {\n  Component.displayName = name\n  return Component\n}\n","import {Store, is, Scope} from 'effector'\nimport React from 'react'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {throwError} from './throw'\nimport {createWatch} from './createWatch'\nimport {withDisplayName} from './withDisplayName'\n\nconst stateReader = <T>(store: Store<T>, scope?: Scope) =>\n  scope ? scope.getState(store) : store.getState()\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\nconst createNotifier = () =>\n  React.useReducer((n: any, action: void) => n + 1, 0)[1]\n\nexport function useStoreBase<State>(store: Store<State>, scope?: Scope) {\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const currentValue = stateReader(store, scope)\n  const inc = createNotifier()\n  const currentStore = React.useRef({\n    store,\n    value: currentValue,\n    pending: false,\n  })\n  useIsomorphicLayoutEffect(() => {\n    const stop = createWatch(\n      store,\n      upd => {\n        const ref = currentStore.current\n        if (!ref.pending) {\n          ref.value = upd\n          ref.pending = true\n          inc()\n          ref.pending = false\n        }\n      },\n      scope,\n    )\n    const newValue = stateReader(store, scope)\n    const ref = currentStore.current\n    if (ref.store === store && ref.value !== newValue) {\n      ref.value = newValue\n      ref.pending = true\n      inc()\n      ref.pending = false\n    }\n    ref.store = store\n    return stop\n  }, [store, scope])\n  return currentValue\n}\n\nexport function useStoreMapBase<State, Result, Keys extends ReadonlyArray<any>>(\n  [configOrStore, separateFn]: [\n    configOrStore:\n      | {\n          store: Store<State>\n          keys: Keys\n          fn(state: State, keys: Keys): Result\n          updateFilter?: (update: Result, current: Result) => boolean\n        }\n      | Store<State>,\n    separateFn?: (state: State, keys: Keys) => Result,\n  ],\n  scope?: Scope,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean =\n    basicUpdateFilter\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = [] as unknown as Keys\n  } else {\n    fn = (configOrStore as any).fn\n    store = (configOrStore as any).store\n    keys = (configOrStore as any).keys\n    updateFilter = (configOrStore as any).updateFilter || basicUpdateFilter\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n  const result = React.useRef<{\n    fn: (state: State, keys: Keys) => Result\n    upd: (update: Result, current: Result) => boolean\n    val: Result\n    init: boolean\n    store: Store<State>\n  }>({} as any)\n  const refState = result.current\n  refState.fn = fn\n  refState.upd = updateFilter\n  refState.init = refState.store === store\n  refState.store = store\n  const inc = createNotifier()\n  const deps = [scope, ...keys]\n  const stop = React.useMemo(() => {\n    updateRef(stateReader(store, scope), keys, result.current)\n    return createWatch(\n      store,\n      val => updateRef(val, keys, result.current, inc),\n      scope,\n    )\n  }, deps)\n  useIsomorphicLayoutEffect(() => () => stop(), deps)\n  return refState.val\n}\nfunction updateRef<State, Keys, Result>(\n  sourceValue: State,\n  keys: Keys,\n  refState: {\n    fn: (state: State, keys: Keys) => Result\n    upd: (update: Result, current: Result) => boolean\n    val: Result\n    init: boolean\n  },\n  inc?: React.DispatchWithoutAction,\n) {\n  const newValue = refState.fn(sourceValue, keys)\n  if (!refState.init) {\n    refState.val = newValue\n    refState.init = true\n  } else {\n    if (\n      newValue !== undefined &&\n      basicUpdateFilter(newValue, refState.val) &&\n      refState.upd(newValue, refState.val)\n    ) {\n      refState.val = newValue\n      inc && inc()\n    }\n  }\n}\nexport function useListBase<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  scope?: Scope,\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: (item: T) => string\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    fn = renderItem.fn\n    if (renderItem.getKey) getKey = renderItem.getKey\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMapBase(\n          [\n            {\n              store: list,\n              keys: [index, ...keys],\n              fn: (list, keys) => list[keys[0]],\n            },\n          ],\n          scope,\n        )\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, scope, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    return useStoreBase(list, scope).map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMapBase(\n      [\n        {\n          store: list,\n          keys: [list],\n          fn: list => list.length,\n        },\n      ],\n      scope,\n    )\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n","import {Event, Store} from 'effector'\nimport {useStoreBase, useStoreMapBase, useListBase} from './apiBase'\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent<T>(event: Event<T>): (payload: T) => T {\n  return event\n}\n\nexport function useStore<State>(store: Store<State>): State {\n  return useStoreBase(store)\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  return useStoreMapBase([configOrStore, separateFn])\n}\n\nexport function useList<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n      }\n    | ((item: T, index: number) => React.ReactNode),\n): React.ReactNode {\n  return useListBase(list, renderItem)\n}\n","import React from 'react'\nimport {Store, is, combine, createEvent} from 'effector'\nimport {useStore} from './nossr'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {StoreView} from './index.h'\nimport {withDisplayName} from './withDisplayName'\nimport {throwError} from './throw'\n\nexport function createComponent<Props, State>(\n  shape: Store<State> | {[key: string]: Store<any> | any},\n  renderProp: (props: Props, state: State) => React.ReactNode,\n): StoreView<State, Props> {\n  let store: Store<any>\n  if (is.store(shape)) {\n    store = shape\n  } else {\n    if (typeof shape === 'object' && shape !== null) {\n      store = combine(shape)\n    } else throwError('shape should be a store or object with stores')\n  }\n  let storeName = 'Unknown'\n  //@ts-ignore\n  if (store && store.shortName) {\n    storeName = store.shortName\n  }\n  const mounted = createEvent<any>()\n  const unmounted = createEvent<any>()\n\n  function RenderComponent(props: Props) {\n    const propsRef = React.useRef(props)\n    const state = useStore(store)\n    useIsomorphicLayoutEffect(() => {\n      mounted({props: propsRef.current, state: store.getState()})\n      return () => {\n        unmounted({props: propsRef.current, state: store.getState()})\n      }\n    }, [])\n    const result = renderProp(props, state)\n    propsRef.current = props\n    return result\n  }\n  RenderComponent.mounted = mounted\n  RenderComponent.unmounted = unmounted\n  return withDisplayName(`${storeName}.View`, RenderComponent)\n}\n","import {Store} from 'effector'\n\nimport {StoreConsumer} from './index.h'\nimport {createComponent} from './createComponent'\n\nexport function createStoreConsumer<State>(\n  store: Store<State>,\n): StoreConsumer<State> {\n  return createComponent(store, ({children}, state) => children(state))\n}\n","import React from 'react'\nimport {createStore, launch, Store, Domain, createEvent} from 'effector'\nimport {Gate} from './index.h'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {withDisplayName} from './withDisplayName'\n\nexport function useGate<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n) {\n  const propsRef = React.useRef<{value: any; count: number}>({\n    value: null,\n    count: 0,\n  })\n  useIsomorphicLayoutEffect(() => {\n    GateComponent.open(propsRef.current.value)\n    return () => GateComponent.close(propsRef.current.value) as any\n  }, [GateComponent])\n  if (!shallowCompare(propsRef.current.value, props)) {\n    propsRef.current.value = props\n    propsRef.current.count += 1\n  }\n  useIsomorphicLayoutEffect(() => {\n    GateComponent.set(propsRef.current.value)\n  }, [propsRef.current.count])\n}\n\nfunction shallowCompare(a: any, b: any) {\n  if (a === b) return true\n  if (\n    typeof a === 'object' &&\n    a !== null &&\n    typeof b === 'object' &&\n    b !== null\n  ) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      const key = aKeys[i]\n      if (a[key] !== b[key]) return false\n    }\n    return true\n  }\n  return false\n}\nexport function createGateImplementation<State>({\n  name = 'gate',\n  domain,\n  defaultState,\n  hook: useGateHook,\n}: {\n  name?: string\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGate\n}): Gate<State> {\n  const fullName = `${domain ? `${domain.compositeName.fullName}/` : ''}${name}`\n  const set = createEvent<State>(`${fullName}.set`)\n  const open = createEvent<State>(`${fullName}.open`)\n  const close = createEvent<State>(`${fullName}.close`)\n  const status = createStore(Boolean(false), {\n    name: `${fullName}.status`,\n  })\n    .on(open, () => Boolean(true))\n    .on(close, () => Boolean(false))\n  const state = createStore(defaultState as State, {\n    name: `${fullName}.state`,\n  })\n    .on(set, (_, state) => state)\n    .reset(close)\n  if (domain) {\n    const {hooks} = domain as any\n    launch({\n      target: [\n        hooks.store,\n        hooks.store,\n        hooks.event,\n        hooks.event,\n        hooks.event,\n      ] as any,\n      params: [status, state, open, close, set],\n    })\n  }\n  function GateComponent(props: State) {\n    useGateHook(GateComponent as any, props)\n    return null\n  }\n  GateComponent.open = open\n  GateComponent.close = close\n  GateComponent.status = status\n  GateComponent.state = state\n  GateComponent.set = set\n  return withDisplayName(`Gate:${fullName}`, GateComponent)\n}\nexport function createGate<Props>(\n  name: string = 'gate',\n  defaultState: Props = {} as any,\n): Gate<Props> {\n  let domain\n  if (typeof name === 'object' && name !== null) {\n    if ('defaultState' in name) {\n      //@ts-ignore\n      defaultState = name.defaultState\n    }\n    //@ts-ignore\n    if (name.domain) domain = name.domain\n    //@ts-ignore\n    name = name.name\n  }\n  return createGateImplementation({\n    name,\n    domain,\n    defaultState,\n    hook: useGate,\n  })\n}\n","import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","export const deprecate = (method: string) =>\n  console.error(`${method} is deprecated`)\n","import React from 'react'\nimport type {Store} from 'effector'\nimport {useStore} from './nossr'\nimport {withDisplayName} from './withDisplayName'\nimport {deprecate} from './deprecate'\n\nexport const createContextComponent = <Props, State, Context>(\n  store: Store<State>,\n  context: React.Context<Context>,\n  renderProp: (props: Props, state: State, context: Context) => React.ReactNode,\n): React.ComponentType<Props> => {\n  deprecate('createContextComponent')\n  return withDisplayName(\n    `${store.shortName || 'Unknown'}.ContextComponent`,\n    (props: any) => {\n      const ctx = React.useContext(context)\n      const state = useStore(store)\n      return renderProp(props, state, ctx)\n    },\n  )\n}\n","import React from 'react'\n\nimport type {Store} from 'effector'\nimport {useStore} from './nossr'\nimport {withDisplayName} from './withDisplayName'\n\nexport const connect =\n  <State>(Component: React.ComponentType<any>) =>\n  (store: Store<State>) => {\n    let View: any = Component\n    if (typeof Component !== 'function') {\n      View = store\n      store = Component as any\n    }\n    const wrappedComponentName = View.displayName || View.name || 'Unknown'\n    return withDisplayName(`Connect(${wrappedComponentName})`, (props: any) =>\n      React.createElement(View, {...props, ...useStore(store)}),\n    )\n  }\n","import type {ComponentType} from 'react'\nimport type {Store} from 'effector'\n\nimport {connect} from './connect'\nimport {deprecate} from './deprecate'\n\nexport const createReactState = (\n  store: Store<any>,\n  View: ComponentType<any>,\n) => {\n  deprecate('createReactState')\n  return connect(View)(store)\n}\n"]},"metadata":{},"sourceType":"module"}