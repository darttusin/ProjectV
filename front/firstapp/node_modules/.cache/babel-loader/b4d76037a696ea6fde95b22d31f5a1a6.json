{"ast":null,"code":"function e(e, t) {\n  for (let r in e) t(e[r], r);\n}\n\nfunction t(e, t) {\n  e.forEach(t);\n}\n\nfunction r(e, t) {\n  if (!e) throw Error(t);\n}\n\nfunction n(e, t) {\n  Ne = {\n    parent: Ne,\n    value: e,\n    template: Ie(e, 'template') || Fe(),\n    sidRoot: Ie(e, 'sidRoot') || Ne && Ne.sidRoot\n  };\n\n  try {\n    return t();\n  } finally {\n    Ne = je(Ne);\n  }\n}\n\nfunction a({\n  node: e = [],\n  from: r,\n  source: n,\n  parent: a = r || n,\n  to: o,\n  target: l,\n  child: s = o || l,\n  scope: i = {},\n  meta: f = {},\n  family: c = {\n    type: 'regular'\n  },\n  regional: u\n} = {}) {\n  let d = Re(a),\n      p = Re(c.links),\n      m = Re(c.owners),\n      g = [];\n  t(e, e => e && G(g, e));\n  let h = {\n    id: ae(),\n    seq: g,\n    next: Re(s),\n    meta: f,\n    scope: i,\n    family: {\n      type: c.type || \"crosslink\",\n      links: p,\n      owners: m\n    }\n  };\n  return t(p, e => G(we(e), h)), t(m, e => G(Se(e), h)), t(d, e => G(e.next, h)), u && Ne && $e(Ce(Ne), [h]), h;\n}\n\nfunction o(e, r, n) {\n  let a = Je,\n      o = null,\n      l = Ue;\n  if (e.target && (r = e.params, n = e.defer, a = 'page' in e ? e.page : a, e.stack && (o = e.stack), l = Ae(e) || l, e = e.target), l && Ue && l !== Ue && (Ue = null), Array.isArray(e)) for (let t = 0; t < e.length; t++) Le('pure', a, ke(e[t]), o, r[t], l);else Le('pure', a, ke(e), o, r, l);\n  if (n && !He) return;\n  let s,\n      i,\n      f,\n      c,\n      u,\n      d,\n      p = {\n    isRoot: He,\n    currentPage: Je,\n    scope: Ue,\n    isWatch: Ge\n  };\n  He = 0;\n\n  e: for (; c = Ee();) {\n    let {\n      idx: e,\n      stack: r,\n      type: n\n    } = c;\n    f = r.node, Je = u = r.page, Ue = Ae(r), u ? d = u.reg : Ue && (d = Ue.reg);\n    let a = !!u,\n        o = !!Ue,\n        l = {\n      fail: 0,\n      scope: f.scope\n    };\n    s = i = 0;\n\n    for (let t = e; t < f.seq.length && !s; t++) {\n      let c = f.seq[t];\n\n      if (c.order) {\n        let {\n          priority: a,\n          barrierID: o\n        } = c.order,\n            l = o ? u ? `${u.fullID}_${o}` : o : 0;\n\n        if (t !== e || n !== a) {\n          o ? We.has(l) || (We.add(l), Be(t, r, a, o)) : Be(t, r, a);\n          continue e;\n        }\n\n        o && We.delete(l);\n      }\n\n      switch (c.type) {\n        case 'mov':\n          {\n            let e,\n                t = c.data;\n\n            switch (t.from) {\n              case z:\n                e = Ce(r);\n                break;\n\n              case \"a\":\n              case 'b':\n                e = r[t.from];\n                break;\n\n              case \"value\":\n                e = t.store;\n                break;\n\n              case \"store\":\n                if (d && !d[t.store.id]) if (a) {\n                  let e = Xe(u, t.store.id);\n                  r.page = u = e, e ? d = e.reg : o ? (Ze(Ue, t.store, 0, 1, t.softRead), d = Ue.reg) : d = void 0;\n                } else o && Ze(Ue, t.store, 0, 1, t.softRead);\n                e = ge(d && d[t.store.id] || t.store);\n            }\n\n            switch (t.to) {\n              case z:\n                r.value = e;\n                break;\n\n              case \"a\":\n              case 'b':\n                r[t.to] = e;\n                break;\n\n              case \"store\":\n                Ye(u, Ue, f, t.target).current = e;\n            }\n\n            break;\n          }\n\n        case 'compute':\n          let e = c.data;\n\n          if (e.fn) {\n            Ge = 'watch' === Ie(f, 'op');\n            let t = e.safe ? (0, e.fn)(Ce(r), l.scope, r) : et(l, e.fn, r);\n            e.filter ? i = !t : r.value = t, Ge = p.isWatch;\n          }\n\n      }\n\n      s = l.fail || i;\n    }\n\n    if (!s) {\n      let e = Ce(r);\n      t(f.next, t => {\n        Le('child', u, t, r, e, Ae(r));\n      });\n      let n = Ae(r);\n\n      if (n) {\n        Ie(f, 'needFxCounter') && Le('child', u, n.fxCount, r, e, n), Ie(f, 'storeChange') && Le('child', u, n.storeChange, r, e, n);\n        let a = n.additionalLinks[f.id];\n        a && t(a, t => {\n          Le('child', u, t, r, e, n);\n        });\n      }\n    }\n  }\n\n  He = p.isRoot, Je = p.currentPage, Ue = Ae(p);\n}\n\nfunction l(t, r = \"combine\") {\n  let n = r + '(',\n      a = '',\n      o = 0;\n  return e(t, e => {\n    o < 25 && (null != e && (n += a, n += _(e) ? tt(e).fullName : e.toString()), o += 1, a = ', ');\n  }), n + ')';\n}\n\nfunction s(e, t) {\n  e.shortName = t, Object.assign(tt(e), i(t, je(e)));\n}\n\nfunction i(e, t) {\n  let r,\n      n,\n      a = e;\n\n  if (t) {\n    let a = tt(t);\n    0 === e.length ? (r = a.path, n = a.fullName) : (r = a.path.concat([e]), n = 0 === a.fullName.length ? e : a.fullName + '/' + e);\n  } else r = 0 === e.length ? [] : [e], n = e;\n\n  return {\n    shortName: a,\n    fullName: n,\n    path: r\n  };\n}\n\nfunction f(e, t) {\n  let r = t ? e : e[0];\n  return Y(r), r.and && (e = r.and), [e, r.or];\n}\n\nfunction c(e, ...t) {\n  let r = Fe();\n\n  if (r) {\n    let n = r.handlers[e];\n    if (n) return n(r, ...t);\n  }\n}\n\nfunction u(e, t) {\n  let r = (e, ...t) => (J(!Ie(r, 'derived'), 'call of derived event', 'createEvent'), Je ? ((e, t, r, n) => {\n    let a = Je,\n        o = null;\n    if (t) for (o = Je; o && o.template !== t;) o = je(o);\n    Qe(o);\n    let l = e.create(r, n);\n    return Qe(a), l;\n  })(r, n, e, t) : r.create(e, t)),\n      n = Fe();\n\n  return Object.assign(r, {\n    graphite: a({\n      meta: pt(\"event\", r, e, t),\n      regional: 1\n    }),\n    create: e => (o({\n      target: r,\n      params: e,\n      scope: Ue\n    }), e),\n    watch: e => ut(r, e),\n    map: e => gt(r, R, e, [ie({\n      fn: ve\n    })]),\n    filter: e => gt(r, \"filter\", e.fn ? e : e.fn, [fe({\n      fn: ve\n    })]),\n    filterMap: e => gt(r, 'filterMap', e, [ie({\n      fn: ve\n    }), ue(e => !X(e), 1)]),\n\n    prepend(e) {\n      let t = u('* \\u2192 ' + r.shortName, {\n        parent: je(r)\n      });\n      return c('eventPrepend', ke(t)), ft(t, r, [ie({\n        fn: ve\n      })], 'prepend', e), dt(r, t), t;\n    }\n\n  });\n}\n\nfunction d(e, n) {\n  let l = me(e),\n      s = mt('updates');\n  c('storeBase', l);\n  let i = l.id,\n      f = {\n    subscribers: new Map(),\n    updates: s,\n    defaultState: e,\n    stateRef: l,\n\n    getState() {\n      let e,\n          t = l;\n\n      if (Je) {\n        let t = Je;\n\n        for (; t && !t.reg[i];) t = je(t);\n\n        t && (e = t);\n      }\n\n      return !e && Ue && (Ze(Ue, l, 1), e = Ue), e && (t = e.reg[i]), ge(t);\n    },\n\n    setState: e => o({\n      target: f,\n      params: e,\n      defer: 1,\n      scope: Ue\n    }),\n    reset: (...e) => (t(e, e => f.on(e, () => f.defaultState)), f),\n    on: (e, r) => (ee(e, '.on', 'first argument'), J(!Ie(f, 'derived'), '.on in derived store', 'createStore'), t(Array.isArray(e) ? e : [e], e => {\n      f.off(e), Me(f).set(e, st(ht(e, f, 'on', be, r)));\n    }), f),\n\n    off(e) {\n      let t = Me(f).get(e);\n      return t && (t(), Me(f).delete(e)), f;\n    },\n\n    map(e, t) {\n      let r, n;\n      K(e) && (r = e, e = e.fn), J(X(t), 'second argument of store.map', 'updateFilter');\n      let a = f.getState();\n      Fe() ? n = null : X(a) || (n = e(a, t));\n      let o = d(n, {\n        name: `${f.shortName} \\u2192 *`,\n        derived: 1,\n        and: r\n      }),\n          s = ht(f, o, R, ye, e);\n      return he(xe(o), {\n        type: R,\n        fn: e,\n        from: l\n      }), xe(o).noInit = 1, c('storeMap', l, s), o;\n    },\n\n    watch(e, t) {\n      if (!t || !_(e)) {\n        let t = ut(f, e);\n        return c('storeWatch', l, e) || e(f.getState()), t;\n      }\n\n      return r(Q(t), 'second argument should be a function'), e.watch(e => t(f.getState(), e));\n    }\n\n  },\n      u = pt(\"store\", f, n),\n      p = f.defaultConfig.updateFilter;\n  f.graphite = a({\n    scope: {\n      state: l,\n      fn: p\n    },\n    node: [ue((e, t, r) => (r.scope && !r.scope.reg[l.id] && (r.b = 1), e)), de(l), ue((e, t, {\n      a: r,\n      b: n\n    }) => !X(e) && (e !== r || n), 1), p && fe({\n      fn: ye\n    }), se({\n      from: z,\n      target: l\n    })],\n    child: s,\n    meta: u,\n    regional: 1\n  });\n  let m = Ie(f, 'sid');\n  return m && ('ignore' !== Ie(f, 'serialize') && qe(f, 'storeChange', 1), l.sid = m), r(Ie(f, 'derived') || !X(e), \"current state can't be undefined, use null instead\"), $e(f, [s]), f;\n}\n\nfunction p(...e) {\n  let t, n, a;\n  [e, a] = f(e);\n  let o,\n      l,\n      s,\n      i = e[e.length - 1];\n\n  if (Q(i) ? (n = e.slice(0, -1), t = i) : n = e, 1 === n.length) {\n    let e = n[0];\n    V(e) || (o = e, l = 1);\n  }\n\n  if (!l && (o = n, t)) {\n    s = 1;\n    let e = t;\n\n    t = t => e(...t);\n  }\n\n  return r(K(o), 'shape should be an object'), yt(Array.isArray(o), !s, o, a, t);\n}\n\nfunction m(...e) {\n  return J(0, 'createStoreObject', 'combine'), p(...e);\n}\n\nfunction g() {\n  let e = {};\n  return e.req = new Promise((t, r) => {\n    e.rs = t, e.rj = r;\n  }), e.req.catch(() => {}), e;\n}\n\nfunction h(e, t) {\n  let n = u(Q(e) ? {\n    handler: e\n  } : e, t),\n      l = ke(n);\n  qe(l, 'op', n.kind = \"effect\"), n.use = e => (r(Q(e), '.use argument should be a function'), m.scope.handler = e, n), n.use.getCurrent = () => m.scope.handler;\n  let s = n.finally = mt('finally'),\n      i = n.done = s.filterMap({\n    named: 'done',\n\n    fn({\n      status: e,\n      params: t,\n      result: r\n    }) {\n      if ('done' === e) return {\n        params: t,\n        result: r\n      };\n    }\n\n  }),\n      f = n.fail = s.filterMap({\n    named: 'fail',\n\n    fn({\n      status: e,\n      params: t,\n      error: r\n    }) {\n      if ('fail' === e) return {\n        params: t,\n        error: r\n      };\n    }\n\n  }),\n      c = n.doneData = i.map({\n    named: 'doneData',\n    fn: ({\n      result: e\n    }) => e\n  }),\n      p = n.failData = f.map({\n    named: 'failData',\n    fn: ({\n      error: e\n    }) => e\n  }),\n      m = a({\n    scope: {\n      handlerId: Ie(l, 'sid'),\n      handler: n.defaultConfig.handler || (() => r(0, `no handler used in ${n.getType()}`))\n    },\n    node: [ue((e, t, r) => {\n      let n = t,\n          a = n.handler;\n\n      if (Ae(r)) {\n        let e = Ae(r).handlers[n.handlerId];\n        e && (a = e);\n      }\n\n      return e.handler = a, e;\n    }, 0, 1), ue(({\n      params: e,\n      req: t,\n      handler: r,\n      args: n = [e]\n    }, a, o) => {\n      let l = vt(e, t, 1, s, o),\n          i = vt(e, t, 0, s, o),\n          [f, c] = bt(r, i, n);\n      f && (K(c) && Q(c.then) ? c.then(l, i) : l(c));\n    }, 0, 1)],\n    meta: {\n      op: 'fx',\n      fx: 'runner'\n    }\n  });\n  l.scope.runner = m, G(l.seq, ue((e, {\n    runner: t\n  }, r) => {\n    let n = je(r) ? {\n      params: e,\n      req: {\n        rs(e) {},\n\n        rj(e) {}\n\n      }\n    } : e;\n    return o({\n      target: t,\n      params: n,\n      defer: 1,\n      scope: Ae(r)\n    }), n.params;\n  }, 0, 1)), n.create = e => {\n    let t = g(),\n        r = {\n      params: e,\n      req: t\n    };\n\n    if (Ue) {\n      if (!Ge) {\n        let e = Ue;\n        t.req.finally(() => {\n          Ke(e);\n        }).catch(() => {});\n      }\n\n      o({\n        target: n,\n        params: r,\n        scope: Ue\n      });\n    } else o(n, r);\n\n    return t.req;\n  };\n  let h = n.inFlight = d(0, {\n    named: 'inFlight'\n  }).on(n, e => e + 1).on(s, e => e - 1);\n  qe(s, 'needFxCounter', 'dec'), qe(n, 'needFxCounter', 1);\n  let y = n.pending = h.map({\n    fn: e => e > 0,\n    named: 'pending'\n  });\n  return $e(n, [s, i, f, c, p, y, h]), n;\n}\n\nfunction y(e) {\n  let t;\n  [e, t] = f(e, 1);\n  let {\n    source: r,\n    effect: n,\n    mapParams: a\n  } = e,\n      l = h(e, t);\n  qe(l, 'attached', 1);\n  let s,\n      {\n    runner: i\n  } = ke(l).scope,\n      c = ue((e, t, n) => {\n    let s,\n        {\n      params: i,\n      req: f,\n      handler: c\n    } = e,\n        u = l.finally,\n        d = vt(i, f, 0, u, n),\n        p = n.a,\n        m = L(c),\n        g = 1;\n\n    if (a ? [g, s] = bt(a, d, [i, p]) : s = r && m ? p : i, g) {\n      if (!m) return e.args = [p, s], 1;\n      o({\n        target: c,\n        params: {\n          params: s,\n          req: {\n            rs: vt(i, f, 1, u, n),\n            rj: d\n          }\n        },\n        page: n.page,\n        defer: 1\n      });\n    }\n  }, 1, 1);\n\n  if (r) {\n    let e;\n    V(r) ? (e = r, $e(e, [l])) : (e = p(r), $e(l, [e])), s = [de(xe(e)), c];\n  } else s = [c];\n\n  return i.seq.splice(1, 0, ...s), l.use(n), dt(n, l, \"effect\"), l;\n}\n\nfunction b(...t) {\n  let [[r, n], a] = f(t),\n      o = {};\n  return e(n, (e, t) => {\n    let n = o[t] = u(t, {\n      parent: je(r),\n      config: a\n    });\n    r.on(n, e), dt(r, n);\n  }), o;\n}\n\nfunction v(r, n) {\n  let l = a({\n    family: {\n      type: \"domain\"\n    },\n    regional: 1\n  }),\n      s = {\n    history: {},\n    graphite: l,\n    hooks: {}\n  };\n  l.meta = pt(\"domain\", s, r, n), e({\n    Event: u,\n    Effect: h,\n    Store: d,\n    Domain: v\n  }, (e, r) => {\n    let n = r.toLowerCase(),\n        a = mt(`on${r}`);\n    s.hooks[n] = a;\n    let l = new Set();\n    s.history[`${n}s`] = l, a.create = e => (o(a, e), e), G(ke(a).seq, ue((e, t, r) => (r.scope = null, e))), a.watch(e => {\n      $e(s, [e]), l.add(e), e.ownerSet || (e.ownerSet = l), je(e) || (e.parent = s);\n    }), $e(s, [a]), s[`onCreate${r}`] = e => (t(l, e), a.watch(e)), s[`create${r}`] = s[n] = (t, r) => a(e(t, {\n      parent: s,\n      or: r\n    }));\n  });\n  let i = je(s);\n  return i && e(s.hooks, (e, t) => ft(e, i.hooks[t])), s;\n}\n\nfunction k(e) {\n  Y(e);\n  let t = D in e ? e[D]() : e;\n  r(t.subscribe, 'expect observable to have .subscribe');\n  let n = u(),\n      a = st(n);\n  return t.subscribe({\n    next: n,\n    error: a,\n    complete: a\n  }), n;\n}\n\nfunction w(e, t) {\n  let r = u(t || l(e, 'merge'));\n  return ee(e, 'merge', 'first argument'), ft(e, r, [], 'merge'), r;\n}\n\nfunction S(e, n) {\n  let a = 0;\n  return t(wt, t => {\n    t in e && (r(null != e[t], St(n, t)), a = 1);\n  }), a;\n}\n\nfunction x(...e) {\n  let t,\n      r,\n      n,\n      [[o, l, s], i] = f(e),\n      p = 1;\n  X(l) && K(o) && S(o, 'sample') && (l = o.clock, s = o.fn, p = !o.greedy, t = o.target, r = o.name, n = o.sid, o = o.source), [o, l] = xt(o, l, 'sample'), X(l) && (l = o), ee(l, 'sample', 'clock'), i || r || (r = o.shortName);\n  let m = !!t;\n\n  if (t || (V(o) && V(l) ? t = d(s ? s(ge(xe(o)), ge(xe(l))) : ge(xe(o)), {\n    name: r,\n    sid: n,\n    or: i\n  }) : (t = u(r, i), c('sampleTarget', ke(t)))), V(o)) {\n    let e = xe(o);\n    $e(o, [ft(l, t, [c('sampleSourceLoader'), de(e, !s, p), s && ie({\n      fn: be\n    }), c('sampleSourceUpward', m)], \"sample\", s)]), c('sampleStoreSource', e);\n  } else {\n    let e = me(0),\n        r = me(),\n        n = me();\n    c('sampleNonStoreSource', e, r, n), a({\n      parent: o,\n      node: [se({\n        from: z,\n        target: r\n      }), se({\n        from: \"value\",\n        store: 1,\n        target: e\n      })],\n      family: {\n        owners: [o, t, l],\n        links: t\n      },\n      meta: {\n        op: \"sample\"\n      },\n      regional: 1\n    }), $e(o, [ft(l, t, [c('sampleSourceLoader'), se({\n      from: z,\n      target: n\n    }), de(e, 1), ue(e => e, 1), de(r, 1, p), de(n), s && ie({\n      fn: ye\n    }), c('sampleSourceUpward', m)], \"sample\", s)]);\n  }\n\n  return t;\n}\n\nfunction C(...e) {\n  let t = 'guard',\n      [[n, o], l] = f(e);\n  o || (o = n, n = o.source), S(o, t);\n\n  let {\n    filter: s,\n    greedy: i,\n    clock: c,\n    name: d = l && l.name ? l.name : t\n  } = o,\n      p = o.target || u(d, l),\n      m = _(s);\n\n  return [n, c] = xt(n, c, t), c && (ee(c, t, 'clock'), n = x({\n    source: n,\n    clock: c,\n    greedy: i,\n    fn: m ? null : (e, t) => ({\n      source: e,\n      clock: t\n    })\n  })), ee(p, t, 'target'), m ? x({\n    source: s,\n    clock: n,\n    target: a({\n      node: [ue(({\n        guard: e\n      }) => e, 1), ue(({\n        data: e\n      }) => e)],\n      child: p,\n      meta: {\n        op: t\n      },\n      family: {\n        owners: [n, s, p, ...[].concat(c || [])],\n        links: p\n      },\n      regional: 1\n    }),\n    fn: (e, t) => ({\n      guard: e,\n      data: t\n    }),\n    greedy: i,\n    name: d\n  }) : (r(Q(s), '`filter` should be function or unit'), ft(n, p, c ? [fe({\n    fn: ({\n      source: e,\n      clock: t\n    }, {\n      fn: r\n    }) => r(e, t)\n  }), ue(({\n    source: e\n  }) => e)] : [fe({\n    fn: ve\n  })], t, s)), p;\n}\n\nfunction M(t, r, n) {\n  if (V(t)) return t;\n\n  if (E(t) || L(t)) {\n    let e = je(t),\n        a = d(r, {\n      parent: e,\n      name: t.shortName,\n      and: n\n    });\n    return ft(L(t) ? t.doneData : t, a), e && e.hooks.store(a), a;\n  }\n\n  let a = Array.isArray(t) ? [] : {};\n  return e(t, (e, t) => a[t] = V(e) ? e : d(e, {\n    name: t\n  })), a;\n}\n\nfunction j(...t) {\n  let n,\n      [[o, l], s] = f(t),\n      i = !l;\n  i && (n = o.cases, l = o.match, o = o.source);\n  let d = V(l),\n      p = !_(l) && Q(l),\n      m = !d && !p && K(l);\n  n || (n = {}), i || (r(m, 'match should be an object'), e(l, (e, t) => n[t] = u(s)), n.__ = u(s));\n  let g,\n      h = new Set([].concat(o, Object.values(n))),\n      y = Object.keys(d || p ? n : l);\n  if (d || p) d && h.add(l), g = [d && de(xe(l), 0, 1), ie({\n    safe: d,\n    filter: 1,\n\n    fn(e, t, r) {\n      let n = String(d ? r.a : l(e));\n      Ct(t, U(y, n) ? n : '__', e, r);\n    }\n\n  })];else if (m) {\n    let t = me({});\n    t.type = 'shape';\n    let r,\n        n = [];\n    e(l, (e, a) => {\n      if (_(e)) {\n        r = 1, G(n, a), h.add(e);\n        let o = ft(e, [], [de(t), ue((e, t, {\n          a: r\n        }) => r[a] = e)]);\n\n        if (V(e)) {\n          t.current[a] = e.getState();\n          let r = xe(e);\n          he(t, {\n            from: r,\n            field: a,\n            type: 'field'\n          }), c('splitMatchStore', r, o);\n        }\n      }\n    }), r && c('splitBase', t), g = [r && de(t, 0, 1), fe({\n      fn(e, t, r) {\n        for (let a = 0; a < y.length; a++) {\n          let o = y[a];\n          if (U(n, o) ? r.a[o] : l[o](e)) return void Ct(t, o, e, r);\n        }\n\n        Ct(t, '__', e, r);\n      }\n\n    })];\n  } else r(0, 'expect match to be unit, function or object');\n  if (a({\n    meta: {\n      op: 'split'\n    },\n    parent: o,\n    scope: n,\n    node: g,\n    family: {\n      owners: Array.from(h)\n    },\n    regional: 1\n  }), !i) return n;\n}\n\nfunction A(e, {\n  scope: t,\n  params: r\n}) {\n  if (!_(e)) return Promise.reject(Error('first argument should be unit'));\n  let n = g();\n  n.parentFork = Ue;\n  let {\n    fxCount: a\n  } = t;\n  G(a.scope.defers, n);\n  let l = [e],\n      s = [];\n  return G(s, L(e) ? {\n    params: r,\n    req: {\n      rs(e) {\n        n.value = {\n          status: 'done',\n          value: e\n        };\n      },\n\n      rj(e) {\n        n.value = {\n          status: 'fail',\n          value: e\n        };\n      }\n\n    }\n  } : r), G(l, a), G(s, null), o({\n    target: l,\n    params: s,\n    scope: t\n  }), n.req;\n}\n\nfunction I(e, r) {\n  let n = [];\n\n  (function e(a) {\n    U(n, a) || (G(n, a), \"store\" === Ie(a, 'op') && Ie(a, 'sid') && r(a, Ie(a, 'sid')), t(a.next, e), t(we(a), e), t(Se(a), e));\n  })(e);\n}\n\nfunction q(e, n) {\n  if (Array.isArray(e) && (e = new Map(e)), e instanceof Map) {\n    let a = {};\n    return t(e, (e, t) => {\n      r(_(t), 'Map key should be a unit'), n && n(t, e), r(t.sid, 'unit should have a sid'), r(!(t.sid in a), 'duplicate sid found'), a[t.sid] = e;\n    }), a;\n  }\n\n  return e;\n}\n\nfunction $(e, n) {\n  let o,\n      l = e;\n  B(e) && (o = e, l = n);\n\n  let s = (e => {\n    let r = a({\n      scope: {\n        defers: [],\n        inFlight: 0,\n        fxID: 0\n      },\n      node: [ue((e, t, r) => {\n        je(r) ? 'dec' === Ie(je(r).node, 'needFxCounter') ? t.inFlight -= 1 : (t.inFlight += 1, t.fxID += 1) : t.fxID += 1;\n      }), ie({\n        priority: \"sampler\",\n        batch: 1\n      }), ue((e, r) => {\n        let {\n          defers: n,\n          fxID: a\n        } = r;\n        r.inFlight > 0 || 0 === n.length || Promise.resolve().then(() => {\n          r.fxID === a && t(n.splice(0, n.length), e => {\n            Ke(e.parentFork), e.rs(e.value);\n          });\n        });\n      }, 0, 1)]\n    }),\n        n = a({\n      node: [ue((e, t, r) => {\n        let n = je(r);\n\n        if (n && je(n)) {\n          let t = n.node;\n\n          if (!Ie(t, 'isCombine') || 'combine' !== Ie(je(n).node, 'op')) {\n            let n = Ae(r),\n                a = t.scope.state.id,\n                o = Ie(t, 'sid');\n            n.sidIdMap[o] = a, n.sidValuesMap[o] = e;\n          }\n        }\n      })]\n    }),\n        o = {\n      cloneOf: e,\n      reg: {},\n      sidValuesMap: {},\n      sidIdMap: {},\n\n      getState(e) {\n        if ('current' in e) return Ye(Je, o, null, e).current;\n        let t = ke(e);\n        return Ye(Je, o, t, t.scope.state, 1).current;\n      },\n\n      kind: \"scope\",\n      graphite: a({\n        family: {\n          type: \"domain\",\n          links: [r, n]\n        },\n        meta: {\n          unit: 'fork'\n        },\n        scope: {\n          forkInFlightCounter: r\n        }\n      }),\n      additionalLinks: {},\n      handlers: {},\n      fxCount: r,\n      storeChange: n\n    };\n    return o;\n  })(o);\n\n  if (l) {\n    if (l.values) {\n      let e = q(l.values, e => r(V(e), 'Values map can contain only stores as keys'));\n      Object.assign(s.sidValuesMap, e);\n    }\n\n    l.handlers && (s.handlers = q(l.handlers, e => r(L(e), \"Handlers map can contain only effects as keys\")));\n  }\n\n  return s;\n}\n\nfunction N(e, {\n  values: t\n}) {\n  r(K(t), 'values property should be an object');\n  let n,\n      a,\n      l,\n      s = q(t),\n      i = Object.getOwnPropertyNames(s),\n      f = [],\n      c = [];\n  T(e) ? (n = e, l = 1, r(n.cloneOf, 'scope should be created from domain'), a = ke(n.cloneOf)) : B(e) ? a = ke(e) : r(0, 'first argument of hydrate should be domain or scope'), I(a, (e, t) => {\n    U(i, t) && (G(f, e), G(c, s[t]));\n  }), o({\n    target: f,\n    params: c,\n    scope: n\n  }), l && Object.assign(n.sidValuesMap, s);\n}\n\nfunction F(e, {\n  scope: t\n} = {}) {\n  r(t || Ue, 'scopeBind cannot be called outside of forked .watch');\n  let n = t || Ue;\n  return L(e) ? t => {\n    let r = g();\n    return o({\n      target: e,\n      params: {\n        params: t,\n        req: r\n      },\n      scope: n\n    }), r.req;\n  } : t => (o({\n    target: e,\n    params: t,\n    scope: n\n  }), t);\n}\n\nfunction O(t, n = {}) {\n  let a = n.ignore ? n.ignore.map(({\n    sid: e\n  }) => e) : [],\n      o = {};\n  return e(t.sidValuesMap, (e, r) => {\n    if (U(a, r)) return;\n    let n = t.sidIdMap[r];\n    o[r] = n && n in t.reg ? t.reg[n].current : e;\n  }), 'onlyChanges' in n && !n.onlyChanges && (r(t.cloneOf, 'scope should be created from domain'), I(ke(t.cloneOf), (e, r) => {\n    r in o || U(a, r) || Ie(e, 'isCombine') || 'ignore' === Ie(e, 'serialize') || (o[r] = t.getState(e));\n  })), o;\n}\n\nlet D = 'undefined' != typeof Symbol && Symbol.observable || '@@observable',\n    R = 'map',\n    z = 'stack',\n    _ = e => (Q(e) || K(e)) && 'kind' in e;\n\nconst P = e => t => _(t) && t.kind === e;\n\nlet V = P(\"store\"),\n    E = P(\"event\"),\n    L = P(\"effect\"),\n    B = P(\"domain\"),\n    T = P(\"scope\");\nvar W = {\n  __proto__: null,\n  unit: _,\n  store: V,\n  event: E,\n  effect: L,\n  domain: B,\n  scope: T\n};\n\nlet U = (e, t) => e.includes(t),\n    H = (e, t) => {\n  let r = e.indexOf(t);\n  -1 !== r && e.splice(r, 1);\n},\n    G = (e, t) => e.push(t),\n    J = (e, t, r) => !e && console.error(`${t} is deprecated, use ${r} instead`),\n    K = e => 'object' == typeof e && null !== e,\n    Q = e => 'function' == typeof e,\n    X = e => void 0 === e,\n    Y = e => r(K(e) || Q(e), 'expect first argument be an object');\n\nconst Z = (e, t, n, a) => r(!(!K(e) && !Q(e) || !('family' in e) && !('graphite' in e)), `${t}: expect ${n} to be a unit (store, event or effect)${a}`);\n\nlet ee = (e, r, n) => {\n  Array.isArray(e) ? t(e, (e, t) => Z(e, r, `${t} item of ${n}`, '')) : Z(e, r, n, ' or array of units');\n};\n\nconst te = () => {\n  let e = 0;\n  return () => \"\" + ++e;\n};\n\nlet re = te(),\n    ne = te(),\n    ae = te();\n\nconst oe = (e, t, r, n) => {\n  let a = {\n    id: ne(),\n    type: e,\n    data: t\n  };\n  return r && (a.order = {\n    priority: r\n  }, n && (a.order.barrierID = ++le)), a;\n};\n\nlet le = 0,\n    se = ({\n  from: e = \"store\",\n  store: t,\n  target: r,\n  to: n = r ? \"store\" : z,\n  batch: a,\n  priority: o\n}) => oe('mov', {\n  from: e,\n  store: t,\n  to: n,\n  target: r\n}, o, a),\n    ie = ({\n  fn: e,\n  batch: t,\n  priority: r,\n  safe: n = 0,\n  filter: a = 0\n}) => oe('compute', {\n  fn: e,\n  safe: n,\n  filter: a\n}, r, t),\n    fe = ({\n  fn: e\n}) => ie({\n  fn: e,\n  filter: 1\n}),\n    ce = ({\n  fn: e\n}) => ie({\n  fn: e,\n  priority: \"effect\"\n}),\n    ue = (e, t, r) => ie({\n  fn: e,\n  safe: 1,\n  filter: t,\n  priority: r && \"effect\"\n}),\n    de = (e, t, r) => se({\n  store: e,\n  to: t ? z : \"a\",\n  priority: r && \"sampler\",\n  batch: 1\n}),\n    pe = {\n  mov: se,\n  compute: ie,\n  filter: fe,\n  run: ce\n},\n    me = e => ({\n  id: ne(),\n  current: e\n}),\n    ge = ({\n  current: e\n}) => e,\n    he = (e, t) => {\n  e.before || (e.before = []), G(e.before, t);\n},\n    ye = (e, {\n  fn: t\n}, {\n  a: r\n}) => t(e, r),\n    be = (e, {\n  fn: t\n}, {\n  a: r\n}) => t(r, e),\n    ve = (e, {\n  fn: t\n}) => t(e),\n    ke = e => e.graphite || e,\n    we = e => e.family.owners,\n    Se = e => e.family.links,\n    xe = e => e.stateRef,\n    Ce = e => e.value,\n    Me = e => e.subscribers,\n    je = e => e.parent,\n    Ae = e => e.scope,\n    Ie = (e, t) => ke(e).meta[t],\n    qe = (e, t, r) => ke(e).meta[t] = r,\n    $e = (e, r) => {\n  let n = ke(e);\n  t(r, e => {\n    let t = ke(e);\n    \"domain\" !== n.family.type && (t.family.type = \"crosslink\"), G(we(t), n), G(Se(n), t);\n  });\n},\n    Ne = null,\n    Fe = () => Ne && Ne.template,\n    Oe = e => (e && Ne && Ne.sidRoot && (e = `${Ne.sidRoot}|${e}`), e),\n    De = ({\n  sid: e,\n  name: t,\n  loc: r,\n  method: o,\n  fn: l\n}) => n(a({\n  meta: {\n    sidRoot: Oe(e),\n    name: t,\n    loc: r,\n    method: o\n  }\n}), l);\n\nconst Re = (e = []) => (Array.isArray(e) ? e : [e]).flat().map(ke);\n\nlet ze = null;\n\nconst _e = (e, t) => {\n  if (!e) return t;\n  if (!t) return e;\n  let r;\n  return (e.v.type === t.v.type && e.v.id > t.v.id || Te(e.v.type) > Te(t.v.type)) && (r = e, e = t, t = r), r = _e(e.r, t), e.r = e.l, e.l = r, e;\n},\n      Pe = [];\n\nlet Ve = 0;\n\nfor (; Ve < 6;) G(Pe, {\n  first: null,\n  last: null,\n  size: 0\n}), Ve += 1;\n\nconst Ee = () => {\n  for (let e = 0; e < 6; e++) {\n    let t = Pe[e];\n\n    if (t.size > 0) {\n      if (3 === e || 4 === e) {\n        t.size -= 1;\n        let e = ze.v;\n        return ze = _e(ze.l, ze.r), e;\n      }\n\n      1 === t.size && (t.last = null);\n      let r = t.first;\n      return t.first = r.r, t.size -= 1, r.v;\n    }\n  }\n},\n      Le = (e, t, r, n, a, o) => Be(0, {\n  a: null,\n  b: null,\n  node: r,\n  parent: n,\n  value: a,\n  page: t,\n  scope: o\n}, e),\n      Be = (e, t, r, n = 0) => {\n  let a = Te(r),\n      o = Pe[a],\n      l = {\n    v: {\n      idx: e,\n      stack: t,\n      type: r,\n      id: n\n    },\n    l: null,\n    r: null\n  };\n  3 === a || 4 === a ? ze = _e(ze, l) : (0 === o.size ? o.first = l : o.last.r = l, o.last = l), o.size += 1;\n},\n      Te = e => {\n  switch (e) {\n    case 'child':\n      return 0;\n\n    case 'pure':\n      return 1;\n\n    case 'read':\n      return 2;\n\n    case \"barrier\":\n      return 3;\n\n    case \"sampler\":\n      return 4;\n\n    case \"effect\":\n      return 5;\n\n    default:\n      return -1;\n  }\n},\n      We = new Set();\n\nlet Ue,\n    He = 1,\n    Ge = 0,\n    Je = null,\n    Ke = e => {\n  Ue = e;\n},\n    Qe = e => {\n  Je = e;\n};\n\nconst Xe = (e, t) => {\n  if (e) {\n    for (; e && !e.reg[t];) e = je(e);\n\n    if (e) return e;\n  }\n\n  return null;\n};\n\nlet Ye = (e, t, r, n, a) => {\n  let o = Xe(e, n.id);\n  return o ? o.reg[n.id] : t ? (Ze(t, n, a), t.reg[n.id]) : n;\n},\n    Ze = (e, r, n, a, o) => {\n  let l = e.reg,\n      s = r.sid;\n  if (l[r.id]) return;\n  let i = {\n    id: r.id,\n    current: r.current\n  };\n  if (s && s in e.sidValuesMap && !(s in e.sidIdMap)) i.current = e.sidValuesMap[s];else if (r.before && !o) {\n    let o = 0,\n        s = n || !r.noInit || a;\n    t(r.before, t => {\n      switch (t.type) {\n        case R:\n          {\n            let r = t.from;\n\n            if (r || t.fn) {\n              r && Ze(e, r, n, a);\n              let o = r && l[r.id].current;\n              s && (i.current = t.fn ? t.fn(o) : o);\n            }\n\n            break;\n          }\n\n        case 'field':\n          o || (o = 1, i.current = Array.isArray(i.current) ? [...i.current] : { ...i.current\n          }), Ze(e, t.from, n, a), s && (i.current[t.field] = l[l[t.from.id].id].current);\n      }\n    });\n  }\n  s && (e.sidIdMap[s] = r.id), l[r.id] = i;\n};\n\nconst et = (e, t, r) => {\n  try {\n    return t(Ce(r), e.scope, r);\n  } catch (t) {\n    console.error(t), e.fail = 1;\n  }\n},\n      tt = e => e.compositeName;\n\nlet rt = (t, r = {}) => (K(t) && (rt(t.or, r), e(t, (e, t) => {\n  X(e) || 'or' === t || 'and' === t || (r[t] = e);\n}), rt(t.and, r)), r);\n\nconst nt = (e, t) => {\n  H(e.next, t), H(we(e), t), H(Se(e), t);\n},\n      at = (e, t, r) => {\n  let n;\n  e.next.length = 0, e.seq.length = 0, e.scope = null;\n  let a = Se(e);\n\n  for (; n = a.pop();) nt(n, e), (t || r && 'sample' !== Ie(e, 'op') || \"crosslink\" === n.family.type) && at(n, t, 'on' !== Ie(n, 'op') && r);\n\n  for (a = we(e); n = a.pop();) nt(n, e), r && \"crosslink\" === n.family.type && at(n, t, 'on' !== Ie(n, 'op') && r);\n},\n      ot = e => e.clear();\n\nlet lt = (e, {\n  deep: t\n} = {}) => {\n  let r = 0;\n  if (e.ownerSet && e.ownerSet.delete(e), V(e)) ot(Me(e));else if (B(e)) {\n    r = 1;\n    let t = e.history;\n    ot(t.events), ot(t.effects), ot(t.stores), ot(t.domains);\n  }\n  at(ke(e), !!t, r);\n},\n    st = e => {\n  let t = () => lt(e);\n\n  return t.unsubscribe = t, t;\n},\n    ft = (e, t, r, n, o) => a({\n  node: r,\n  parent: e,\n  child: t,\n  scope: {\n    fn: o\n  },\n  meta: {\n    op: n\n  },\n  family: {\n    owners: [e, t],\n    links: t\n  },\n  regional: 1\n}),\n    ct = e => {\n  let [{\n    from: t,\n    to: r\n  }, n] = f(e, 1);\n  return ee(t, 'forward', '\"from\"'), ee(r, 'forward', '\"to\"'), st(a({\n    parent: t,\n    child: r,\n    meta: {\n      op: 'forward',\n      config: n\n    },\n    family: {},\n    regional: 1\n  }));\n},\n    ut = (e, t) => (r(Q(t), '.watch argument should be a function'), st(a({\n  scope: {\n    fn: t\n  },\n  node: [ce({\n    fn: ve\n  })],\n  parent: e,\n  meta: {\n    op: 'watch'\n  },\n  family: {\n    owners: e\n  },\n  regional: 1\n}))),\n    dt = (e, t, r = \"event\") => {\n  je(e) && je(e).hooks[r](t);\n},\n    pt = (e, t, r, n) => {\n  let a = \"domain\" === e,\n      o = re(),\n      l = rt({\n    or: n,\n    and: 'string' == typeof r ? {\n      name: r\n    } : r\n  }),\n      {\n    parent: s = null,\n    sid: f = null,\n    named: c = null\n  } = l,\n      u = c || l.name || (a ? '' : o),\n      d = i(u, s),\n      p = {\n    op: t.kind = e,\n    name: t.shortName = u,\n    sid: t.sid = Oe(f),\n    named: c,\n    unitId: t.id = o,\n    serialize: l.serialize,\n    derived: l.derived\n  };\n\n  if (t.parent = s, t.compositeName = d, t.defaultConfig = l, t.thru = e => (J(0, 'thru', 'js pipe'), e(t)), t.getType = () => d.fullName, !a) {\n    t.subscribe = e => (Y(e), t.watch(Q(e) ? e : t => e.next && e.next(t))), t[D] = () => t;\n    let e = Fe();\n    e && (p.nativeTemplate = e);\n  }\n\n  return p;\n},\n    mt = e => u({\n  named: e\n});\n\nconst gt = (e, t, r, n) => {\n  let a;\n  K(r) && (a = r, r = r.fn);\n  let o = u({\n    name: `${e.shortName} \\u2192 *`,\n    derived: 1,\n    and: a\n  });\n  return ft(e, o, n, t, r), o;\n},\n      ht = (e, t, r, n, a) => {\n  let o = xe(t),\n      l = se({\n    store: o,\n    to: \"a\",\n    priority: 'read'\n  });\n  r === R && (l.data.softRead = 1);\n  let s = [l, ie({\n    fn: n\n  })];\n  return c('storeOnMap', o, s, V(e) && xe(e)), ft(e, t, s, r, a);\n},\n      yt = (t, n, a, o, s) => {\n  let i = t ? e => e.slice() : e => ({ ...e\n  }),\n      f = t ? [] : {},\n      u = i(f),\n      p = me(u),\n      m = me(1);\n  p.type = t ? 'list' : 'shape', p.noInit = 1, c('combineBase', p, m);\n  let g = d(u, {\n    name: l(a),\n    derived: 1,\n    and: o\n  }),\n      h = xe(g);\n  h.noInit = 1, qe(g, 'isCombine', 1);\n  let y = [ue((e, t, r) => (r.scope && !r.scope.reg[p.id] && (r.c = 1), e)), de(p), se({\n    store: m,\n    to: 'b'\n  }), ue((e, {\n    key: t\n  }, r) => {\n    if (r.c || e !== r.a[t]) return n && r.b && (r.a = i(r.a)), r.a[t] = e, 1;\n  }, 1), se({\n    from: \"a\",\n    target: p\n  }), se({\n    from: \"value\",\n    store: 0,\n    target: m\n  }), se({\n    from: \"value\",\n    store: 1,\n    target: m,\n    priority: \"barrier\",\n    batch: 1\n  }), de(p, 1), s && ie({\n    fn: ve\n  })];\n  return e(a, (e, t) => {\n    if (!V(e)) return r(!_(e) && !X(e), `combine expects a store in a field ${t}`), void (u[t] = f[t] = e);\n    f[t] = e.defaultState, u[t] = e.getState();\n    let n = ft(e, g, y, 'combine', s);\n    n.scope.key = t;\n    let a = xe(e);\n    he(p, {\n      type: 'field',\n      field: t,\n      from: a\n    }), c('combineField', a, n);\n  }), g.defaultShape = a, he(h, {\n    type: R,\n    from: p,\n    fn: s\n  }), Fe() || (g.defaultState = s ? h.current = s(u) : f), g;\n};\n\nlet bt = (e, t, r) => {\n  try {\n    return [1, e(...r)];\n  } catch (e) {\n    return t(e), [0, null];\n  }\n},\n    vt = (e, t, r, n, a) => l => o({\n  target: [n, kt],\n  params: [r ? {\n    status: 'done',\n    params: e,\n    result: l\n  } : {\n    status: 'fail',\n    params: e,\n    error: l\n  }, {\n    value: l,\n    fn: r ? t.rs : t.rj\n  }],\n  defer: 1,\n  page: a.page,\n  scope: Ae(a)\n}),\n    kt = a({\n  node: [ce({\n    fn: ({\n      fn: e,\n      value: t\n    }) => e(t)\n  })],\n  meta: {\n    op: 'fx',\n    fx: 'sidechain'\n  }\n});\n\nconst wt = ['source', 'clock', 'target'],\n      St = (e, t) => e + `: ${t} should be defined`;\n\nlet xt = (e, t, n) => (r(!X(e) || !X(t), St(n, 'either source or clock')), X(e) ? (ee(t, n, 'clock'), Array.isArray(t) && (t = w(t)), e = t) : _(e) || (e = p(e)), [e, t]);\n\nconst Ct = (e, t, r, n) => {\n  let a = e[t];\n  a && o({\n    target: a,\n    params: Array.isArray(a) ? a.map(() => r) : r,\n    defer: 1,\n    stack: n\n  });\n},\n      Mt = \"22.1.1\";\n\nexport { A as allSettled, y as attach, lt as clearNode, p as combine, b as createApi, v as createDomain, h as createEffect, u as createEvent, a as createNode, d as createStore, m as createStoreObject, $ as fork, ct as forward, k as fromObservable, C as guard, N as hydrate, W as is, o as launch, w as merge, M as restore, x as sample, F as scopeBind, O as serialize, s as setStoreName, j as split, pe as step, Mt as version, De as withFactory, n as withRegion };","map":{"version":3,"sources":["effector/collection.ts","effector/throw.ts","effector/region.ts","effector/createNode.ts","effector/tag.ts","effector/kernel.ts","effector/naming.ts","effector/config.ts","effector/template.ts","effector/createUnit.ts","effector/combine.ts","effector/defer.ts","effector/createEffect.ts","effector/attach.ts","effector/createApi.ts","effector/createDomain.ts","effector/fromObservable.ts","effector/merge.ts","effector/sample.ts","effector/guard.ts","effector/restore.ts","effector/split.ts","effector/fork/allSettled.ts","effector/fork/util.ts","effector/fork/fork.ts","effector/fork/createScope.ts","effector/fork/hydrate.ts","effector/fork/scopeBind.ts","effector/fork/serialize.ts","effector/observable.ts","effector/validate.ts","effector/is.ts","effector/id.ts","effector/step.ts","effector/stateRef.ts","effector/caller.ts","effector/getter.ts","effector/own.ts","effector/clearNode.ts","effector/subscription.ts","effector/forward.ts","effector/watch.ts"],"names":["forIn","obj","cb","key","includes","list","item","removeItem","pos","indexOf","splice","add","push","forEach","fn","assert","condition","message","Error","deprecate","subject","suggestion","console","error","regionStack","readTemplate","template","readSidRoot","sid","sidRoot","withRegion","unit","parent","value","getMeta","getParent","withFactory","name","loc","method","createNode","meta","arrifyNodes","Array","isArray","flat","map","getGraph","node","from","source","to","target","child","scope","family","familyRaw","type","regional","sources","links","owners","seq","result","id","nextNodeID","next","link","getOwners","owner","getLinks","own","getValue","MAP","STACK","heap","merge","a","b","ret","v","getPriority","r","l","queue","ix","first","last","size","deleteMin","i","pushFirstHeapItem","page","pushHeap","idx","stack","priority","bucket","t","barriers","Set","isRoot","isWatch","currentPage","forkPage","setForkPage","newForkPage","setCurrentPage","newPage","getPageForRef","reg","getPageRef","ref","isGetState","pageForRef","initRefInScope","launch","payload","upsert","pageForLaunch","stackForLaunch","forkPageForLaunch","params","defer","getForkPage","length","lastStartedState","stop","skip","kernelLoop","hasPageReg","hasScopeReg","local","fail","stepn","step","order","barrierID","fullID","has","delete","data","store","softRead","undefined","readRef","current","computationResult","safe","tryRun","filter","finalValue","nextNode","fxCount","storeChange","additionalLinks","sourceRef","isKernelCall","refsMap","sidValuesMap","sidIdMap","before","isFresh","needToAssign","noInit","cmd","field","err","getCompostite","compositeName","unitObjectName","objOrArr","comma","is","fullName","toString","setStoreName","rawName","shortName","Object","assign","createName","path","composite","concat","processArgsToConfig","args","singleArgument","rawConfig","assertObject","or","and","flattenConfig","part","config","isObject","isVoid","applyTemplate","handlers","applyParentHook","hookType","hooks","initUnit","kind","configA","configB","isDomain","nextUnitID","named","op","unitId","serialize","derived","defaultConfig","thru","getType","subscribe","observer","watch","isFunction","upd","observableSymbol","nativeTemplate","createNamedEvent","createEvent","deriveEvent","event","mapped","createLinkNode","oldPage","create","nameOrConfig","maybeConfig","graphite","watchUnit","compute","callStack","filterMap","calc","prepend","contramapped","createStore","defaultState","props","plainState","createStateRef","updates","plainStateId","subscribers","Map","stateRef","getState","targetRef","reachedPage","setState","state","reset","units","on","nodeSet","assertNodeSet","trigger","off","getSubscribers","set","createSubscription","updateStore","callARegStack","currentSubscription","get","firstState","lastResult","storeState","innerStore","linkNode","callStackAReg","addRefOp","getStoreState","eventOrFn","subscription","updateFilter","_","read","mov","setMeta","caller","storeRef","reader","combine","handler","stores","rawHandler","slice","structStoreShape","shapeReady","noArraySpread","storeCombination","needSpread","clone","stateNew","rawShape","storeStateRef","c","batch","childRef","defaultShape","createStoreObject","createDefer","req","Promise","rs","rj","catch","createEffect","instance","use","runner","getCurrent","anyway","finally","done","status","doneData","failData","handlerId","scope_","handler_","onResolve","onSettled","onReject","ok","runFn","then","fx","savedFork","inFlight","x","pending","amount","sidechain","run","attach","injected","effect","mapParams","attached","runnerSteps","runnerFnStep","sourceData","isEffectHandler","computedParams","createApi","setters","metadata","createDomain","history","Event","Effect","Store","Domain","factory","tag","lowerCaseTag","toLowerCase","acc","res","ownerSet","hook","fromObservable","observable","observableItem","disposer","complete","events","sampleConfigFields","fieldErrorMessage","validateSampleConfig","atLeastOneFieldExists","groupInputs","clock","sample","batched","greedy","isUpward","hasSource","clockState","guard","METHOD","filterFn","filterIsUnit","restore","domain","launchCase","scopeTargets","split","targets","match","knownCases","cases","matchIsUnit","matchIsFunction","matchIsShape","__","values","caseNames","keys","splitterSeq","String","lastValues","needBarrier","storeOrFn","updater","caseName","allSettled","start","ctx","reject","parentFork","defers","launchUnits","launchParams","traverseStores","root","visit","normalizeValues","assertEach","fork","domainOrConfig","optiionalConfig","createScope","valuesSidMap","forkInFlightCounter","fxID","resolve","storeStack","storeNode","resultScope","cloneOf","hydrate","normalizedValues","valuesSidList","getOwnPropertyNames","storeNodes","storeValues","traverseTarget","scopeBind","savedForkPage","ignoredStores","ignore","onlyChanges","Symbol","assertNodeSetItem","valueName","reason","idCount","nextStepID","nextBarrierID","isEffect","toStack","samplerPriority","graph","val","ownerUnit","_link","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","effects","domains","unsubscribe","scopeFn","forward","opts"],"mappings":"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","sourcesContent":["export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(condition: any, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: any,\n  subject: string,\n  suggestion: string,\n) =>\n  !condition &&\n  console.error(`${subject} is deprecated, use ${suggestion} instead`)\n","import {getParent, getMeta} from './getter'\nimport {createNode} from './createNode'\nimport type {Template} from '../forest/index.h'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion(unit: any, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: getMeta(unit, 'template') || readTemplate(),\n    sidRoot: getMeta(unit, 'sidRoot') || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), name, loc, method},\n  })\n  return withRegion(sidNode, fn)\n}\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nconst arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\nexport type Stack = {\n  value: any\n  a: any\n  b: any\n  c?: any\n  parent: Stack | null\n  node: Node\n  page: Leaf | null\n  scope?: Scope | null | void\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  scope?: Scope | null | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void\n  stack?: Stack | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {isRoot, currentPage, scope: forkPage, isWatch}\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem(\n          'child',\n          page,\n          nextNode,\n          stack,\n          finalValue,\n          getForkPage(stack),\n        )\n      })\n      const forkPage = getForkPage(stack)\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nexport const initRefInScope = (\n  scope: {\n    reg: Record<string, StateRef>\n    sidValuesMap: Record<string, any>\n    sidIdMap: Record<string, string>\n  },\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  const sid = sourceRef.sid\n  if (refsMap[sourceRef.id]) return\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n  }\n\n  if (sid && sid in scope.sidValuesMap && !(sid in scope.sidIdMap)) {\n    ref.current = scope.sidValuesMap[sid]\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import type {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\nimport {forIn} from './collection'\n\nconst getCompostite = (unit: any): CompositeName => unit.compositeName\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, (unit: any) => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit) ? getCompostite(unit).fullName : unit.toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompostite(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompostite(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any,\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  if (rawConfig.and) {\n    args = rawConfig.and\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: any = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn: any = template.handlers[method]\n    if (fn) return fn(template, ...args)\n  }\n}\n","import {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport type {Store, Event} from './unit.h'\n\nimport {calc, compute, filter, mov, read} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n} from './kernel'\n\nimport type {Subscriber, Config} from './index.h'\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind: any, unit: any, configA: any, configB?: any) => {\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const config = flattenConfig({\n    or: configB,\n    and: typeof configA === 'string' ? {name: configA} : configA,\n  })\n  const {parent = null, sid = null, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName} → *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  const template = readTemplate()\n  return Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(EVENT, event, nameOrConfig, maybeConfig),\n      regional: true,\n    }),\n    create(params: any, _: any) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: any) => deriveEvent(event, MAP, fn, [compute({fn: callStack})]),\n    filter: (fn: any) =>\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [filter({fn: callStack})]),\n    filterMap: (fn: any) =>\n      deriveEvent(event, 'filterMap', fn, [\n        compute({fn: callStack}),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: any) {\n      const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(\n        contramapped,\n        event,\n        [compute({fn: callStack})],\n        'prepend',\n        fn,\n      )\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: any) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: any[]) {\n      forEach(units, unit => store.on(unit, () => store.defaultState))\n      return store\n    },\n    on(nodeSet: any, fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      deprecate(\n        !getMeta(store, 'derived'),\n        '.on in derived store',\n        'createStore',\n      )\n      forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n        store.off(trigger)\n        getSubscribers(store).set(\n          trigger,\n          createSubscription(\n            updateStore(trigger, store, 'on', callARegStack, fn),\n          ),\n        )\n      })\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = fn.fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName} → *`,\n        derived: true,\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && filter({fn: callStackAReg}),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    if (getMeta(store, 'serialize') !== 'ignore')\n      setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n  }\n  assert(\n    getMeta(store, 'derived') || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, compute({fn: caller})]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, compute, calc, read} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport {callStack} from './caller'\nimport type {Config} from './index.h'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: Config,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => list.slice() : (obj: any) => ({...obj})\n  const defaultState: any = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    read(rawShape),\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && compute({fn: callStack}),\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args: any[]) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch, Stack} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport type {Unit} from './index.h'\nimport {add} from './collection'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig?: any,\n) {\n  const instance: any = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  )\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handlerId: getMeta(node, 'sid'),\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd, scope_, stack) => {\n          const scope: {handlerId: string; handler: Function} = scope_ as any\n          let handler = scope.handler\n          if (getForkPage(stack)) {\n            const handler_ = getForkPage(stack)!.handlers[scope.handlerId]\n            if (handler_) handler = handler_\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        ({params, req, handler, args = [params]}, _, stack) => {\n          const onResolve = onSettled(params, req, true, anyway, stack)\n          const onReject = onSettled(params, req, false, anyway, stack)\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd = getParent(stack)\n          ? {params, req: {rs(data: any) {}, rj(data: any) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch({target: instance, params: payload, scope: forkPage})\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data: any) => void,\n  args: any[],\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): any\n      rj(_: any): any\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n  ) =>\n  (data: any) =>\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      page: stack.page,\n      scope: getForkPage(stack),\n    })\n\nexport const sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import {combine} from './combine'\nimport {createEffect, onSettled, runFn} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {processArgsToConfig} from './config'\nimport {getGraph, getStoreState, setMeta} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {read, calc} from './step'\nimport {launch} from './kernel'\nimport {EFFECT} from './tag'\n\nexport function attach(config: any) {\n  let injected\n  ;[config, injected] = processArgsToConfig(config, true)\n  let {source, effect, mapParams} = config\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope\n  let runnerSteps\n  const runnerFnStep = calc(\n    (upd, _, stack) => {\n      const {params, req, handler} = upd\n      const anyway = attached.finally\n      const rj = onSettled(params, req, false, anyway, stack)\n      const sourceData = stack.a\n      const isEffectHandler = is.effect(handler)\n      let ok = true\n      let computedParams: any\n      if (mapParams) {\n        ;[ok, computedParams] = runFn(mapParams, rj, [params, sourceData])\n      } else {\n        computedParams = source && isEffectHandler ? sourceData : params\n      }\n      if (ok) {\n        if (isEffectHandler) {\n          launch({\n            target: handler as any,\n            params: {\n              params: computedParams,\n              req: {rs: onSettled(params, req, true, anyway, stack), rj},\n            },\n            page: stack.page,\n            defer: true,\n          })\n        } else {\n          upd.args = [sourceData, computedParams]\n          return true\n        }\n      }\n    },\n    true,\n    true,\n  )\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(state, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [read(getStoreState(state)), runnerFnStep]\n  } else {\n    runnerSteps = [runnerFnStep]\n  }\n  runner.seq.splice(1, 0, ...runnerSteps)\n  attached.use(effect)\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import type {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import type {Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {createLinkNode} from './forward'\nimport {add, forEach, forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {calc} from './step'\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const node = createNode({family: {type: DOMAIN}, regional: true})\n\n  const result: any = {\n    history: {},\n    graphite: node,\n    hooks: {},\n  }\n\n  node.meta = initUnit(DOMAIN, result, nameOrConfig, maybeConfig)\n\n  forIn(\n    {\n      Event: createEvent,\n      Effect: createEffect,\n      Store: createStore,\n      Domain: createDomain,\n    },\n    (factory: any, tag) => {\n      const lowerCaseTag = tag.toLowerCase()\n\n      const trigger = createNamedEvent(`on${tag}`)\n      result.hooks[lowerCaseTag] = trigger\n\n      const acc = new Set<any>()\n      result.history[`${lowerCaseTag}s`] = acc\n\n      trigger.create = res => {\n        launch(trigger, res)\n        return res\n      }\n      add(\n        getGraph(trigger).seq,\n        calc((upd, _, stack) => {\n          stack.scope = null\n          return upd\n        }),\n      )\n      trigger.watch(data => {\n        own(result, [data])\n        acc.add(data)\n        if (!data.ownerSet) data.ownerSet = acc\n        if (!getParent(data)) data.parent = result\n      })\n      own(result, [trigger])\n\n      result[`onCreate${tag}`] = (hook: (data: any) => any) => {\n        forEach(acc, hook)\n        return trigger.watch(hook)\n      }\n      result[`create${tag}`] = result[lowerCaseTag] = (\n        nameOrConfig: any,\n        config?: Config,\n      ) => trigger(factory(nameOrConfig, {parent: result, or: config}))\n    },\n  )\n\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) =>\n      createLinkNode(from, parent.hooks[key]),\n    )\n  }\n  return result\n}\n","import {observableSymbol} from './observable'\nimport type {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {assert} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  assert(observableItem.subscribe, 'expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const result = createEvent(config || unitObjectName(events, 'merge'))\n  assertNodeSet(events, 'merge', 'first argument')\n  createLinkNode(events, result, [], 'merge')\n  return result\n}\n","import {combine} from './combine'\nimport {mov, compute, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {assertNodeSet, is, isObject, isVoid} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config: any, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\nexport const groupInputs = (source: any, clock: any, method: string) => {\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  if (isVoid(source)) {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  return [source, clock] as const\n}\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, 'sample')\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  ;[source, clock] = groupInputs(source, clock, 'sample')\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  }\n  assertNodeSet(clock, 'sample', 'clock')\n  if (!metadata && !name) name = source.shortName\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent(name, metadata)\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(\n        clock,\n        target,\n        [\n          applyTemplate('sampleSourceLoader'),\n          read(sourceRef, !fn, batched),\n          fn && compute({fn: callARegStack}),\n          applyTemplate('sampleSourceUpward', isUpward),\n        ],\n        SAMPLE,\n        fn,\n        // scope: {fn, targetTemplate}\n      ),\n    ])\n    applyTemplate('sampleStoreSource', sourceRef)\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceRef = createStateRef()\n    const clockState = createStateRef()\n    applyTemplate('sampleNonStoreSource', hasSource, sourceRef, clockState)\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: SAMPLE},\n      regional: true,\n    })\n    own(source, [\n      createLinkNode(\n        clock,\n        target,\n        [\n          applyTemplate('sampleSourceLoader'),\n          mov({from: STACK, target: clockState}),\n          read(hasSource, true),\n          calc(hasSource => hasSource, true),\n          read(sourceRef, true, batched),\n          read(clockState),\n          fn && compute({fn: callStackAReg}),\n          applyTemplate('sampleSourceUpward', isUpward),\n        ],\n        SAMPLE,\n        fn,\n        // scope: {fn, targetTemplate}\n      ),\n    ])\n  }\n  return target\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {groupInputs, validateSampleConfig, sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {calc, filter} from './step'\nimport {callStack} from './caller'\nimport {assertNodeSet, is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\n\nexport function guard(...args: any[]) {\n  const METHOD = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, METHOD)\n  let {\n    filter: filterFn,\n    greedy,\n    clock,\n    name = metadata && metadata.name ? metadata.name : METHOD,\n  } = config\n  const target = config.target || createEvent(name, metadata)\n  const filterIsUnit = is.unit(filterFn)\n  ;[source, clock] = groupInputs(source, clock, METHOD)\n  if (clock) {\n    assertNodeSet(clock, METHOD, 'clock')\n    source = sample({\n      source,\n      clock,\n      greedy,\n      fn: filterIsUnit ? null : (source: any, clock: any) => ({source, clock}),\n    })\n  }\n  assertNodeSet(target, METHOD, 'target')\n  if (filterIsUnit) {\n    sample({\n      source: filterFn,\n      clock: source,\n      target: createNode({\n        node: [calc(({guard}) => guard, true), calc(({data}) => data)],\n        child: target,\n        meta: {op: METHOD},\n        family: {\n          owners: [source, filterFn, target, ...[].concat(clock ? clock : [])],\n          links: target,\n        },\n        regional: true,\n      }),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    assert(isFunction(filterFn), '`filter` should be function or unit')\n    createLinkNode(\n      source,\n      target,\n      clock\n        ? [\n            filter({fn: ({source, clock}, {fn}) => fn(source, clock)}),\n            calc(({source}) => source),\n          ]\n        : [filter({fn: callStack})],\n      METHOD,\n      filterFn,\n    )\n  }\n  return target\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {createLinkNode} from './forward'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) return obj\n  if (is.event(obj) || is.effect(obj)) {\n    const domain = getParent(obj)\n    const result = createStore(defaultState, {\n      parent: domain,\n      name: obj.shortName,\n      and: config,\n    })\n    createLinkNode(is.effect(obj) ? obj.doneData : obj, result)\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(\n    obj,\n    (value, key) =>\n      (result[key] = is.store(value) ? value : createStore(value, {name: key})),\n  )\n  return result\n}\n","import type {Event} from './unit.h'\nimport type {NodeUnit, Cmd} from './index.h'\nimport {is, isFunction, isObject} from './is'\nimport {add, forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {compute, filter, calc, read} from './step'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {assert} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\n\nconst launchCase = (\n  scopeTargets: Record<string, NodeUnit>,\n  field: string,\n  data: any,\n  stack: any,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]): any {\n  let targets: Record<string, Event<any> | NodeUnit>\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const knownCases = !match\n  if (knownCases) {\n    targets = source.cases\n    match = source.match\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!knownCases) {\n    assert(matchIsShape, 'match should be an object')\n    forIn(match, (_, key) => (targets[key] = createEvent(metadata)))\n    targets.__ = createEvent(metadata)\n  }\n  const owners = new Set(\n    ([] as NodeUnit[]).concat(source, Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && read(getStoreState(match), false, true),\n      compute({\n        safe: matchIsUnit,\n        filter: true,\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn: any, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        add(units, key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(\n          storeOrFn,\n          [],\n          [read(lastValues), calc((upd, _, {a}) => (a[key] = upd))],\n        )\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {from: storeRef, field: key, type: 'field'})\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && read(lastValues, false, true),\n      filter({\n        fn(data, scopeTargets, stack) {\n          for (let i = 0; i < caseNames.length; i++) {\n            const caseName = caseNames[i]\n            const caseValue = includes(units, caseName)\n              ? stack.a[caseName]\n              : match[caseName](data)\n            if (caseValue) {\n              launchCase(scopeTargets, caseName, data, stack)\n              return\n            }\n          }\n          launchCase(scopeTargets, '__', data, stack)\n        },\n      }),\n    ]\n  } else {\n    assert(false, 'expect match to be unit, function or object')\n  }\n  createNode({\n    meta: {op: 'split'},\n    parent: source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {owners: Array.from(owners)},\n    regional: true,\n  })\n  if (!knownCases) return targets\n}\n","import {add} from '../collection'\nimport {createDefer} from '../defer'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\nexport function allSettled(\n  start: any,\n  {scope, params: ctx}: {scope: Scope; params?: any},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-expect-error\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  add(fxCount.scope.defers, defer)\n\n  const launchUnits = [start]\n  const launchParams = [] as Array<{params: any; req: any} | null>\n  add(\n    launchParams,\n    is.effect(start)\n      ? {\n          params: ctx,\n          req: {\n            rs(value: any) {\n              //@ts-ignore\n              defer.value = {status: 'done', value}\n            },\n            rj(value: any) {\n              //@ts-ignore\n              defer.value = {status: 'fail', value}\n            },\n          },\n        }\n      : ctx,\n  )\n  add(launchUnits, fxCount)\n  add(launchParams, null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    scope,\n  })\n  return defer.req\n}\n","import {getMeta, getOwners, getLinks} from '../getter'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport type {Store} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {STORE} from '../tag'\n\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    add(list, node)\n    if (getMeta(node, 'op') === STORE && getMeta(node, 'sid')) {\n      fn(node, getMeta(node, 'sid'))\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\nexport function normalizeValues(\n  values: Map<Store<any>, any> | Array<[any, any]> | Record<string, any>,\n  assertEach?: (key: any, value: any) => void,\n) {\n  if (Array.isArray(values)) values = new Map(values)\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    forEach(values, (value, key) => {\n      assert(is.unit(key), 'Map key should be a unit')\n      if (assertEach) assertEach(key, value)\n      assert(key.sid, 'unit should have a sid')\n      assert(!(key.sid! in result), 'duplicate sid found')\n      result[key.sid!] = value\n    })\n    return result\n  }\n  return values\n}\n","import {is} from '../is'\nimport {assert} from '../throw'\nimport type {Domain} from '../unit.h'\nimport {normalizeValues} from './util'\nimport {createScope} from './createScope'\n\nexport function fork(\n  domainOrConfig?: Domain | {values?: any; handlers?: any},\n  optiionalConfig?: {values?: any; handlers?: any},\n) {\n  let config: {values?: any; handlers?: any} | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    domain = domainOrConfig\n    config = optiionalConfig\n  }\n\n  const scope = createScope(domain!)\n\n  if (config) {\n    if (config.values) {\n      const valuesSidMap = normalizeValues(config.values, unit =>\n        assert(is.store(unit), 'Values map can contain only stores as keys'),\n      )\n      Object.assign(scope.sidValuesMap, valuesSidMap)\n    }\n    if (config.handlers) {\n      scope.handlers = normalizeValues(config.handlers, unit =>\n        assert(\n          is.effect(unit),\n          `Handlers map can contain only effects as keys`,\n        ),\n      )\n    }\n  }\n  return scope\n}\n","import {getForkPage, getGraph, getMeta, getParent} from '../getter'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {calc, compute} from '../step'\nimport type {Domain, Scope} from '../unit.h'\nimport type {StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, SCOPE} from '../tag'\n\nexport function createScope(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      calc((_, scope, stack) => {\n        if (!getParent(stack)) {\n          scope.fxID += 1\n          return\n        }\n        if (getMeta(getParent(stack).node, 'needFxCounter') === 'dec') {\n          scope.inFlight -= 1\n        } else {\n          scope.inFlight += 1\n          scope.fxID += 1\n        }\n      }),\n      compute({priority: SAMPLER, batch: true}),\n      calc(\n        (_, scope) => {\n          const {defers, fxID} = scope\n          if (scope.inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), (defer: any) => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n        false,\n        true,\n      ),\n    ],\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      calc((value, __, stack) => {\n        const storeStack = getParent(stack)\n        if (storeStack && getParent(storeStack)) {\n          const storeNode = storeStack.node\n          if (\n            !getMeta(storeNode, 'isCombine') ||\n            getMeta(getParent(storeStack).node, 'op') !== 'combine'\n          ) {\n            const forkPage = getForkPage(stack)!\n            const id = storeNode.scope.state.id\n            const sid = getMeta(storeNode, 'sid')\n            forkPage.sidIdMap[sid] = id\n            forkPage.sidValuesMap[sid] = value\n          }\n        }\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    sidValuesMap: {},\n    sidIdMap: {},\n    getState(store: any) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, null, store).current\n      }\n      const node = getGraph(store)\n      return getPageRef(currentPage, resultScope, node, node.scope.state, true)\n        .current\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {},\n    fxCount: forkInFlightCounter,\n    storeChange,\n  }\n  return resultScope\n}\n","import {is, isObject} from '../is'\nimport {assert} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, includes} from '../collection'\nimport {normalizeValues, traverseStores} from './util'\nimport {getGraph} from '../getter'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values: any}) {\n  assert(isObject(values), 'values property should be an object')\n  const normalizedValues = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(normalizedValues)\n  const storeNodes: Node[] = []\n  const storeValues: any[] = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  let needToAssign: true | void\n  if (is.scope(domain)) {\n    forkPage = domain\n    needToAssign = true\n    assert(forkPage.cloneOf, 'scope should be created from domain')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    traverseTarget = getGraph(domain)\n  } else {\n    assert(false, 'first argument of hydrate should be domain or scope')\n  }\n  traverseStores(traverseTarget!, (node, sid) => {\n    // forkPage.sidIdMap[sid] = node.scope.state.id\n    if (includes(valuesSidList, sid)) {\n      add(storeNodes, node)\n      add(storeValues, normalizedValues[sid])\n    }\n  })\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    scope: forkPage!,\n  })\n  if (needToAssign) {\n    Object.assign(forkPage!.sidValuesMap, normalizedValues)\n  }\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\n/** bind event to scope */\nexport function scopeBind(unit: any, {scope}: {scope?: Scope} = {}) {\n  assert(\n    scope || forkPage,\n    'scopeBind cannot be called outside of forked .watch',\n  )\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          scope: savedForkPage,\n        })\n        return req.req\n      }\n    : (params: any) => {\n        launch({target: unit, params, scope: savedForkPage})\n        return params\n      }\n}\n","import type {Scope, Store} from '../unit.h'\nimport {forIn, includes} from '../collection'\nimport {assert} from '../throw'\nimport {traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  config: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const ignoredStores = config.ignore ? config.ignore.map(({sid}) => sid) : []\n  const result = {} as Record<string, any>\n  forIn(scope.sidValuesMap, (value, sid) => {\n    if (includes(ignoredStores, sid)) return\n    const id = scope.sidIdMap[sid]\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = scope.reg[id].current\n    } else {\n      result[sid] = value\n    }\n  })\n  if ('onlyChanges' in config && !config.onlyChanges) {\n    assert(scope.cloneOf, 'scope should be created from domain')\n    traverseStores(getGraph(scope.cloneOf), (node, sid) => {\n      if (\n        !(sid in result) &&\n        !includes(ignoredStores, sid) &&\n        !getMeta(node, 'isCombine') &&\n        getMeta(node, 'serialize') !== 'ignore'\n      )\n        result[sid] = scope.getState(node as any)\n    })\n  }\n  return result\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {Domain, Effect, Event, Scope, Store} from './unit.h'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: any) => value is Store<unknown>\nexport const event = is(EVENT) as (value: any) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: any,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value: any) => value is Domain\nexport const scope = is(SCOPE) as (value: any) => value is Scope\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const isVoid = (value: any) => value === undefined\n\nexport const assertObject = (value: any) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: any,\n  method: string,\n  valueName: string,\n  reason: string,\n) =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: any,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag, Stack} from './kernel'\n\nconst cmd = (\n  type: 'compute' | 'mov',\n  data: any,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result: any = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = ({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n}: {\n  fn?: (data: any, scope: {[key: string]: any}, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n}): Compute => cmd('compute', {fn, safe, filter}, priority, batch)\n\nexport const filter = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, filter: true})\n\nexport const run = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, priority: EFFECT})\n\nexport const calc = (\n  fn: (data: any, scope: {[key: string]: any}, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import type {Stack} from './kernel'\n\nexport const callStackAReg = (stack: any, {fn}: any, {a}: Stack) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: Stack) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: Stack) => fn(stack)\n","import type {Node, StateRef} from './index.h'\nimport type {Scope} from './unit.h'\n\nexport const getGraph = (graph: any): Node => graph.graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: any): StateRef => store.stateRef\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any): Scope | void => val.scope\nexport const getMeta = (unit: any, field: string) => getGraph(unit).meta[field]\nexport const setMeta = (unit: any, field: string, value: any) =>\n  (getGraph(unit).meta[field] = value)\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, 'forward', '\"from\"')\n  assertNodeSet(to, 'forward', '\"to\"')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: 'forward', config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n"]},"metadata":{},"sourceType":"module"}